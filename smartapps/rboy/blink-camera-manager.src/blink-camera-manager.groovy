/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "05.08.00"
}

def releaseTimeStamp() { //YYYYMMDDHHSS
    return "201701121100"
}

/**
*  Blink Camera Service Configuration Manager
*
* Copyright RBoy, redistribution of code is not allowed without permission
* 2017-1-12 - (v5.8.0) Updated URLs to new blink infrastructure and use the new registration mechanism
* 2016-11-16 - Updated video recording length to a maximum of 120 seconds
* 2016-10-23 - Added ability to check for new code versions automatically once a week
* 2016-9-28 - Fine tune battery level calibration
* 2016-9-22 - Enabled singleInstance for the SmartApp, since accounts now support multiple sync modules per account, only allow one instance to avoid multiple confusions
* 2016-9-16 - Patch for broken HREF in ST app 2.2.0
* 2016-9-13 - Added support to set motion sensitivity and retrigger time and optimize logging with ST platform fix for parent-child smartapp-devices
* 2016-8-26 - Improve battery reporting accuracy
* 2016-8-17 - Added support for ST Contact Address book
* 2016-7-26 - Added support for Amazon SNS notifications for Blink upgrade
* 2016-7-5 - Added option to arm the cameras on mode change (like SHM)
* 2016-7-5 - Accidentally enabled polling option, used only for debugging, push is what's recommended by Blink
* 2016-6-23 - Fix for error while trying to install the device
* 2016-6-23 - Fix for SHM and random errors for some users
* 2016-6-23 - Correction of log message
* 2016-6-7 - Correct mode name of SHM to Disarm in options
* 2016-6-3 - Fix for logout
* 2016-6-3 - Added support for non-US worldwide regions
* 2016-6-2 - Added support for multiple sync modules in a single account
* 2016-5-31 - Send push notification if OAuth is not enabled in the settings
* 2016-5-17 - Send a notification no more than once per hour if the sync module is offline
* 2016-5-15 - Notify use if timezone/location is missing in setup
* 2016-5-6 - Fix for finding physical hubs
* 2016-5-6- Throw an exception if the user hasn't selected a hub
* 2016-5-6 - Put a proper fix for handling multiple hubs and creation of new devices
* 2016-5-5 - Temporary fix for create new devices by using the 1st available hub on the location - ST really broke the API this time
* 2016-4-34 - Debug message
* 2016-4-23 - Use display names instead of device names
* 2016-4-23 - Added support for live viewing of camera
* 2016-4-20 - Moved version to the top of the page
* 2016-4-19 - Fix for battery showing > 100%
* 2016-4-19 - Fixed version string
* 2016-4-16 - Added support to convert from F to C if required
* 2016-4-14 - Reset motion status when SM or Camera motion detection is turned off
* 2016-4-14 - Added support to configure video recording length
* 2016-4-12 - Performance optimization, don't need to query network ID each time, save it for future use since it doesn't change
* 2016-4-12 - Check for empty response
* 2016-4-12 - Reduced possibility of timeout when initializing app while refreshing all cameras
* 2016-4-7 - Updated checking endpoint codes for logged out clients, cleaned up logging in
* 2016-4-7 - Added cleanup of clients and URL registrations, logout unnecessary clients and only register the SmartApp logins with URL's (not device logins)
* 2016-4-5 - Added support for push notification from blink
* 2016-4-5 - Use homescreen endpoint instead of cameras endpoint to work around Blink server bug for rebooting cameras
* 2016-4-5 - Added support for multiple instance of Blink Camera Manager, one for each sync module (login)
* 2016-4-3 - Debug stuff
* 2016-4-2 - Debug messages to help find issues
* 2016-3-31 - Fix for ST platform state variable issue causing it lose track of last motion check resulting in previous motion events being reported as motion detection
* 2016-3-31 - Updated comment on switch interface to bring it more inline with Blink's definition
* 2016-3-30 - Fixed wrong version number reported
* 2016-3-29 - Fixed issue with  motion detection being reported when turning on camera if previous motion events were not processed
* 2016-3-29 - Improved UI layout
* 2016-3-22 - Added support to check for sync module going offline and reporting it to the user (don't send commands if sync module is offline)
* 2016-3-18 - Use the sync module to get information rather than polling each camera endpoint (Blink fixed endpoint), should improve performance significantly
* 2016-3-10 - Clarified description of options
* 2016-3-10 - Changed identifier string to reflect the ST client name and version number
* 2016-3-9 - Optimized and improved reliability of motion check timers and reduced server load
* 2016-3-8 - Fix for alternative detection of events from cameras (main sync module event broken till 3/19/16)
* 2016-3-8 - Added version information on top while configuring
* 2016-3-8 - Added support for integration with SHM
* 2016-3-7 - Added option to retry commands on failure (or turn it off)
* 2016-3-7 - Reusing auth token on the request to blink engineers to reduce server load
* 2016-3-7 - Optimize heartbeat system and schedule it on app install
* 2016-3-6 - Added heartbeat kickstart
* 2016-3-5 - Bugfix for scheduler backup kickstarter
* 2016-3-5 - Brand new scheduling system to make motion detection more reliable and resistant to the broken ST platform timer issues
* 2016-3-5 - Revamped the motion detection code to optimize calls to Blink server to reduce issues with the crappy ST platform timeout problem
* 2016-3-5 - Moved the refresh code on initialization to a referred run to avoid a timeout issue when many devices are configured
* 2016-3-4 - Fix for sending multiple commands to the server in a short period causing a conflict and command failure, queue and retry failed commands in 5 seconds
* 2016-3-4 - Added support to customize switch interface behavior to either control individual cameras or the entire system (sync module)
* 2016-3-3 - Clean up the code to stop execution additional commands if the camera is in conflict/busy to avoid throwing more errors
* 2016-3-3 - Dont' check for motion alerts if camera is disbaled
* 2016-3-2 - Bugfix for not being able to turn off intruder alerts
* 2016-3-2 - Kick start monitoring of events everytime camera is enabled just incast ST killed the timers
* 2016-3-2 - Poll period is a variable now and motion inactivity is linked to it
* 2016-3-2 - Default action is now to enable/disable camera. Motion must be enabled at global level for camera enable/disable to work
* 2016-3-1 - Added options to configure actions after a motion is detected
* 2016-3-1 - Added support for Motion Event notifications through Motion Sensor Interface
* 2016-2-29 - Added support for forcing camera sensors update and reporting last time they were updated
* 2016-2-27 - Added support for WiFi and LFR signal
* 2016-2-26 - Fixed issues with taking camera pictures and referred processing
* 2016-2-26 - Fixed battery reporting
* 2016-2-23 - Initial release
*
*/
definition(
    name: "Blink Camera Manager",
    namespace: "rboy",
    author: "RBoy",
    description: "Install, configure and manage your Blink cameras",
    category: "Safety & Security",
    iconUrl: "http://smartthings.rboyapps.com/images/Blink.jpg",
    iconX2Url: "http://smartthings.rboyapps.com/images/Blink.jpg",
    iconX3Url: "http://smartthings.rboyapps.com/images/Blink.jpg",
    singleInstance: true)

import groovy.json.JsonSlurper
 
preferences {
    page(name: "mainPage")
    page(name: "modeArmPage")
    page(name: "motionSecurityPage")
    page(name: "modeConfigureCameraPage")
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Blink Camera Manager v${clientVersion()}", install: true, uninstall: true) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            section("INVALID HUB LOCATION") {
                paragraph title: "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately", required: true, ""
            }
        }

        // Let the user know the current status
        def cameras = null // use later on also
        section("Blink Account Status") {
            if (blinkLogin && blinkPassword) {
                if (login()) {
                    cameras = getBlinkCamerasList()
                    logout() // Logout so we clear the DB from hanging clients
                    if (cameras) {
                        paragraph "Found ${cameras.size()} camera(s)"
                        cameras.each { camera ->
                            paragraph "Camera: $camera.name"
                        }
                    } else {
                        log.warn "No cameras found"
                        paragraph "No cameras found in account"
                    }
                } else {
                    log.error "Error getting account details"
                    paragraph title: "INVALID LOGIN: ERROR getting account details, check Login credentials or service is offline.", required: true, ""
                }
            } else {
                log.warn "Invalid authentication credentials entered, Login: $blinkLogin, Password: $blinkPassword"
                paragraph title: "PLEASE ENTER BLINK ACCOUNT LOGIN DETAILS!", required: true, ""
            }
        }

        section("Blink Authentication") {
            input name: "blinkLogin", type: "text", title: "Login (eMail)", submitOnChange: true, required: true
            input name: "blinkPassword", type: "password", title: "Password", submitOnChange: true, required: true
        }

        def physicalHubs = location.hubs.findAll { it.type == physicalgraph.device.HubType.PHYSICAL } // Ignore Virtual hubs
        if (physicalHubs.size() > 1) { // If there is more than one hub then select the hub otherwise we'll the default hub
            section("Hub Selection") {
                paragraph title: "", "Multiple SmartThings Hubs have been detected at this location. Please select the Hub which is on the same network as the Blink cameras."
                input name: "installHub", type: "hub", title: "Select the Hub which can communicate with the Blink cameras", required: true
            }
        }

        section("Motion Detected Actions") {
            paragraph "Use this page to configure actions such as turning on alarms, lights and sending notifications when the camera is armed and motion is detected"
            href(name: "toMotionSecurityPage", params: hrefParams, title: "Configure actions when motion is detected", page: "motionSecurityPage", description: "", required: false)
        }
        
        section("Smart Home Monitor (SHM) and Modes Integration") {
            def childCameras = getChildDevices()
            if (!childCameras) {
                paragraph "Complete Blink SmartApp setup and initialization to configure these options"                
            } else {
                def hrefParams = [
                    cameras: childCameras, 
                    passed: true 
                ]
                paragraph "Camera motion detection arming/disarming can be configured directly through Routines and SHM. However, if you're facing an issue with Routines or SHM you can also use this page to Enable/Disable Motion Detection via this SmartApp when SHM and Mode change"
                href(name: "toModeArm", params: hrefParams, title: "Arm/Disarm cameras for specific SHM/Modes", page: "modeArmPage", description: "", required: false)

                paragraph "Use this to change the camera configuration (motion sensivitivity/video recording length) for each mode"
                href(name: "toModeConfigureCamera", params: hrefParams, title: "Modes based camera configuration (advanced)", page: "modeConfigureCameraPage", description: "", required: false)
            }
        }

        section("Advanced Settings (optional)") {
            input "enableRetry", "bool", title: "Retry commands on server error", defaultValue: "true", required: false
            paragraph "Switch Interface Behavior (optional)\nEach camera exposes itself as a Switch to ST which allows you to control the motion detection feature (Arming/Disarming) through SmartApps and Routines.\nThis option determines how it will behave when a Switch On/Off request is received.\nEnabling this option will Arm/Disarm the Blink system (sync module) Arming/Disarming motion detection for the individual cameras"
            input "switchControlsSystem", "bool", title: "Switch Interface Arms/Disarms System instead of Camera", required: false
            //input "enablePollingEvents", "bool", title: "Poll Blink for motion events instead of using Push notifications (NOT recommended)", defaultValue: "false", required: false // DEBUGGING ONLY
        }

        section("Change Name of App (optional)") {
            label title: "Assign a name", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }
    }
}

def motionSecurityPage() {
    dynamicPage(name: "motionSecurityPage", title: "Camera Armed and Motion Detected Actions", install: false, uninstall: false) {    
        section("", hidden: ((recipients || sms || push || alarms || alarmSilent || lights || picture) ? false : true), hideable: false) {
            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false) {
                paragraph title: "Notifications", "You can enter multiple phone numbers to send an SMS to by separating them with a '+'. E.g. 5551234567+4447654321"
                input "sms", "phone", title: "Send SMS Notification to (optional)", required: false
                input "push", "bool", title: "Send Push Notification", required: false
            }
            paragraph " "
            paragraph title: "External Alarms", "Select the external Alarm device to activate (sound and strobe) when motion is detected on the camera. When Silent Alarm is enabled, only the strobe light is activated."
            input "alarms", "capability.alarm", title: "Alarm to turn on if motion is detected", multiple: true, required: false
            input "alarmSilent", "bool", title: "Silent Alarm", required: false
            paragraph " "
            paragraph title: "Lights", "Select the lights or switches to activate when motion is detected on the camera"
            input "lights", "capability.switch", title: "Select lights/switches to turn on if motion is detected", multiple: true, required: false, submitOnChange:true
            if (lights) {
                input "lightTimer", "number", title: "Turn off lights/switches after (minutes)", description: "Leave empty to not turn off lights/switches", required: false
            }
            paragraph " "
            paragraph title: "Pictures", "Enable this option to have SmartThings take a picture when motion is detected on the camera"
            input "picture", "bool", title: "Take picture if motion is detected", required: false
        }
    }
}

def modeArmPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def cameras = null
    // Get cameras from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.cameras) {
        cameras = params.cameras
        log.trace "Passed from main page, using params lookup for cameras $cameras"
    } else if (atomicState.params) {
        cameras = atomicState.params.cameras ?: null
        log.trace "Passed from submitOnChange, atomicState lookup for cameras $cameras"
    } else {
        log.error "Invalid params, no cameras found. Params: $params, saved params: $atomicState.params"
    }
    
    def cameraNames = cameras*.label.sort()

    log.trace "Mode Arm Page, cameras:$cameras, cameraNames:$cameraNames"
    log.trace "Passed params: $params, saved params:$atomicState.params"

    dynamicPage(name: "modeArmPage", title: "", install: false, uninstall: false) {    
        section("About") {
            paragraph "Use this page to arm/disarm motion monitoring for specified cameras when SHM or the Mode changes."
        }

        section ("SHM Integration"){
            if (!cameraNames) {
                paragraph "No Blink Cameras found"
            } else {
                def lastArmAway = settings."shmArmAway"
                def lastDisarmAway = settings."shmDisarmAway"
                def lastArmStay = settings."shmArmStay"
                def lastDisarmStay = settings."shmDisarmStay"
                def lastDisarm = settings."shmDisarm"
                log.trace "Last armed cameras for SHM Away are $lastArmAway, disarmed cameras are $lastDisarmAway"
                log.trace "Last armed cameras for SHM Stay are $lastArmStay, disarmed cameras are $lastDisarmStay"
                log.trace "Last disarmed cameras for SHM Disarm are $lastDisarm"

                paragraph "When SHM is Away..."
                if (lastArmAway) {
                    input name: "shmArmAway", type: "enum", title: "Arm these cameras", options: cameraNames, defaultValue: lastArmAway, description: "Select cameras", required: false, multiple: true
                } else {
                    input name: "shmArmAway", type: "enum", title: "Arm these cameras", options: cameraNames, description: "Select cameras", required: false, multiple: true
                }
                if (lastDisarmAway) {
                    input name: "shmDisarmAway", type: "enum", title: "Disarm these cameras", options: cameraNames, defaultValue: lastDisarmAway, description: "Select cameras", required: false, multiple: true
                } else {
                    input name: "shmDisarmAway", type: "enum", title: "Disarm these cameras", options: cameraNames, description: "Select cameras", required: false, multiple: true
                }
                paragraph " " // Blank space

                paragraph "When SHM is Stay..."
                if (lastArmStay) {
                    input name: "shmArmStay", type: "enum", title: "Arm these cameras", options: cameraNames, defaultValue: lastArmStay, description: "Select cameras", required: false, multiple: true
                } else {
                    input name: "shmArmStay", type: "enum", title: "Arm these cameras", options: cameraNames, description: "Select cameras", required: false, multiple: true
                }
                if (lastDisarmStay) {
                    input name: "shmDisarmStay", type: "enum", title: "Disarm these cameras", options: cameraNames, defaultValue: lastDisarmStay, description: "Select cameras", required: false, multiple: true
                } else {
                    input name: "shmDisarmStay", type: "enum", title: "Disarm these cameras", options: cameraNames, description: "Select cameras", required: false, multiple: true
                }
                paragraph " " // Blank space

                paragraph "When SHM is Disarmed..."
                if (lastDisarm) {
                    input name: "shmDisarm", type: "enum", title: "Disarm these cameras", options: cameraNames, defaultValue: lastDisarm, description: "Select cameras", required: false, multiple: true
                } else {
                    input name: "shmDisarm", type: "enum", title: "Disarm these cameras", options: cameraNames, description: "Select cameras", required: false, multiple: true
                }
            }
        }

        section ("Mode Integration"){
            if (!cameraNames) {
                paragraph "No Blink Cameras found"
            } else {
                for (mode in location.modes) {
                    def lastArm = settings."arm${mode}"
                    def lastDisarm = settings."disarm${mode}"
                    log.trace "Last armed cameras for $mode are $lastArm, disarmed cameras for $mode are $lastDisarm"

                    paragraph "When Mode is $mode..."
                    if (lastArm) {
                        input name: "arm${mode}", type: "enum", title: "Arm these cameras", options: cameraNames, defaultValue: lastArm, description: "Select cameras", required: false, multiple: true
                    } else {
                        input name: "arm${mode}", type: "enum", title: "Arm these cameras", options: cameraNames, description: "Select cameras", required: false, multiple: true
                    }
                    if (lastDisarm) {
                        input name: "disarm${mode}", type: "enum", title: "Disarm these cameras", options: cameraNames, defaultValue: lastDisarm, description: "Select cameras", required: false, multiple: true
                    } else {
                        input name: "disarm${mode}", type: "enum", title: "Disarm these cameras", options: cameraNames, description: "Select cameras", required: false, multiple: true
                    }
                    paragraph " " // Blank Space
                }
            }
        }
    }
}

def modeConfigureCameraPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def cameras = null
    // Get cameras from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.cameras) {
        cameras = params.cameras
        log.trace "Passed from main page, using params lookup for cameras $cameras"
    } else if (atomicState.params) {
        cameras = atomicState.params.cameras ?: null
        log.trace "Passed from submitOnChange, atomicState lookup for cameras $cameras"
    } else {
        log.error "Invalid params, no cameras found. Params: $params, saved params: $atomicState.params"
    }

    def cameraNames = cameras?.collect { camera -> camera.label }.sort()

    log.trace "Mode Configure Camera Page, cameras:$cameras, cameraNames:$cameraNames"
    log.trace "Passed params: $params, saved params:$atomicState.params"

    dynamicPage(name: "modeConfigureCameraPage", title: "", install: false, uninstall: false) {    
        section("About") {
            paragraph "Use this page to change camera configuration for each Mode"
        }

        for (mode in location.modes) {
            section ("When in Mode $mode", hideable: true){
                if (!cameraNames) {
                    paragraph "No Blink Cameras found"
                } else {
                    for (camera in cameraNames) {
                        input "videoLength${camera}${mode}", "number", title: "$camera Recording Length(s)", range:"(1..120)", description: "Between 1 and 120 seconds", required: false
                        input "sensitivity${camera}${mode}", "number", title: "$camera Motion Sensitivity", range:"(1..9)", description: "1 (lowest) to 9 (highest)", required: false
                        paragraph " " // Blank Space
                    }
                }
            }
        }
    }
}

def installed()
{
    log.debug "Installed: $settings"
    initialize()
}

def updated()
{
    log.debug "Updated: $settings"

    unsubscribe()
    unschedule()
    initialize()
}

def uninstalled() {
    log.trace "Uninstalled called"
    getChildDevices().each {device ->
        device.logout() // clear any pending clients from the blink servers by logging out of the child contexts
        log.info "Deleting Blink Camera Device $device.displayName"
        deleteChildDevice(device.deviceNetworkId)
    }

    logout() // clear any pending clients from this context
}

def initialize() {
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }

    def physicalHubs = location.hubs.findAll { it.type == physicalgraph.device.HubType.PHYSICAL } // Ignore Virtual hubs
    log.trace "Selected Hub ID ${installHub?.id}, All Hubs Types: ${location.hubs*.type}, Names: ${location.hubs*.name}, IDs: ${location.hubs*.id}, IPs: ${location.hubs*.localIP}, Total Hubs Found: ${location.hubs.size()}, Physical Hubs Found: ${physicalHubs.size()}"

    def cameras = []
    if (login()) { // Check if we have valid login credentials otherwise it goes into a loop
        cameras = getBlinkCamerasList()
        logout() // logout here since we won't use this token again (device will create it's token)
    } else {
        log.error "Invalid authentication credentials entered, Login: $blinkLogin, Password: $blinkPassword"
        sendNotification "Invalid Blink Login or Password entered" // Let the user know
    }

    // Create a device for each new camera in the blink account
    cameras.each { camera ->
        try {
            def existingDevice = getChildDevice(camera.id)
            if(!existingDevice) {
                if ((physicalHubs.size() > 1) && !installHub) {
                    log.error "Found more than one physical hub and user has NOT selected a hub in the SmartApp settings"
                    throw new RuntimeException("Select Hub in SmartApp settings") // Lets not continue with out this settings
                }
                if (physicalHubs.size() < 1) {
                    log.error "NO Physical hubs found at this location, please contact SmartThings support!"
                    throw new RuntimeException("No physical hubs found") // Lets not continue with out this settings
                }
                log.info "Creating Blink Camera Device $camera.name on Hub Id ${physicalHubs.size() > 1 ? installHub.id : physicalHubs[0].id}"
                //def childDevice = addChildDevice("rboy", "RBoy Blink Camera", camera.id, null, [name: "Blink $camera.name", label: "Blink $camera.name", completedSetup: true]) // null no longer seems to work for hub after 5.5.16, it's broken
                def childDevice = addChildDevice("rboy", "RBoy Blink Camera", camera.id, (physicalHubs.size() > 1 ? installHub.id : physicalHubs[0].id), [name: "Blink $camera.name", label: "Blink $camera.name", completedSetup: true])
            } else {
                // Update networkId of Camera incase it's changed for future (performance improvement, each call to Blink is 2-3 seconds) and this is the most used call
                existingDevice.logout() // Logout of the context of existing client and start afresh with a new token for security
                log.trace "Blink Camera $existingDevice.displayName already exists"
            }

            atomicState."networkID${camera.id}" = camera.network // Save networkId of Camera for future (performance improvement, each call to Blink is 2-3 seconds) and this is the most used call
            atomicState."lastMotionCheck${camera.id}" = now() // Set the initial reference to check for motion events, use atomicState when using across child/parent interfaces since child cannot update state variables
            log.trace "Initializing last motion event checked at ${new Date(atomicState."lastMotionCheck${camera.id}").format("EEE MMM dd yyyy HH:mm:ss z", timeZone)} for Camera $camera.name"
        } catch (e) {
            log.error "Error creating device: ${e}"
            sendNotification "Error creating Blink camera device"
            throw e // Don't lose the exception here
        }
    }

    // Delete devices for any cameras that are no longer in the blink account
    def delete = getChildDevices().findAll { device -> !cameras?.id.contains(device.deviceNetworkId) }
    delete.each {device ->
        log.info "Deleting Blink Camera Device $device.displayName as it no longer exists in the Blink account"
        try {
            deleteChildDevice(device.deviceNetworkId)
        } catch (e) {
            log.error e
            sendNotification "Device $device.displayName still in use. Remove from any SmartApps or Dashboards, then try again"
            throw e // Don't lose the exception here
        }
    }

    // Update the Switch interface behavior for the camera and reset the rate limit
    getChildDevices().each { device ->
        rateLimitExceeded(device.deviceNetworkId, true) // Reset the rate limit for each device
        device.updateSwitchBehavior(switchControlsSystem)
    }

    atomicState.lastMotionMonitorCheck = 0 // use atomicState when using across child/parent interfaces since child cannot update state variables
    atomicState.lastHeartBeat = 0 // use atomicState when using across child/parent interfaces since child cannot update state variables
    atomicState.authToken = [] //We have no valid auth token now, reset it
    atomicState.baseServer = null //We have no valid base server now, reset it

    setupCallBackURL() // Initialize the ST access token to enable Blink event call backs, this is only done from SmartApp context and not device context (we need only 1 callback URL)

    // Subscribe to events to trigger kick start to compensate for broken ST timers
    if (enablePollingEvents) {
        subscribe(location, "sunrise", kickStart)
        subscribe(location, "sunset", kickStart)
        runEvery5Minutes(kickStart) // Start the heartBeat system
    }

    // SHM Integration
    subscribe(location, "alarmSystemStatus", shmHandler)
    subscribe(location, "mode", modeHandler) // Mode based camera arming/disarming

    subscribe(app, resetRateLimits) // Allow use to reset rate limits at the touch of a button

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm

    runIn(1, refreshAll) // Refresh all devices status to get switch status and do it offline to avoid timing out
    runIn(60, resetRateLimits) // Reset the rate limits once the device initialization is complete to allow normal usage
}

// User touch app
def appTouch(evt) {
    log.trace "User called appTouch, reinitializing"
    initialize()
}

// Mode integration
def modeHandler(evt) {
    log.trace "Mode change handler called with state $evt.value"
    def mode = evt.value

    // Check for Mode based arming/disarming
    if (!settings."arm${mode}" && !settings."disarm${mode}") {
        log.trace "No camera disarm actions configured for Mode $mode"
    } else {
        getChildDevices().each { device ->
            if (settings."arm${mode}"?.contains(device.displayName)) {
                log.trace "Enabling ${device.displayName} Camera Motion Detection for Mode $mode"
                device.deferredLoopbackQueue(1, "enableAlerts") // Do it offline other the app times out with large number of cameras
            } else {
                log.trace "No arm action defined for ${device.displayName} for Mode $mode"
            }

            if (settings."disarm${mode}"?.contains(device.displayName)) {
                log.trace "Disabling ${device.displayName} Camera Motion Detection for Mode $mode"
                device.deferredLoopbackQueue(1, "disableAlerts") // Do it offline other the app times out with large number of cameras
            } else {
                log.trace "No disarm action defined for ${device.displayName} for Mode $mode"
            }
        }
    }
    
    // Check for mode based camera configurations
    getChildDevices().each { device ->
        def camera = device.displayName
        
        if (settings."videoLength${camera}${mode}") {
            log.trace "Configuring ${device.displayName} Camera Recording Video Length to ${settings."videoLength${camera}${mode}"} for Mode $mode"
            device.deferredLoopbackQueue(1, "setVideoRecordingLength", [settings."videoLength${camera}${mode}"]) // Do it offline other the app times out with large number of cameras
        }

        if (settings."sensitivity${camera}${mode}") {
            log.trace "Configuring ${device.displayName} Camera Motion Sensitivity to ${settings."sensitivity${camera}${mode}"} for Mode $mode"
            device.deferredLoopbackQueue(1, "setMotionSensitivity", [settings."sensitivity${camera}${mode}"]) // Do it offline other the app times out with large number of cameras
        }
    }
    
    kickStart(evt) // Kickstart incase timer died
}

// Integration with SHM
def shmHandler(evt) {
    log.trace "SHM handler called with state $evt.value"

    switch (evt.value) {
        case "stay":
            if (shmArmStay) {
                getChildDevices().each { device ->
                    if (shmArmStay.contains(device.displayName)) {
                        log.trace "Enabling ${device.displayName} Camera Motion Detection on Stay"
                        device.deferredLoopbackQueue(1, "enableAlerts") // Do it offline other the app times out with large number of cameras
                    } else {
                        log.trace "No arm action defined for ${device.displayName} on Stay"
                    }
                }
            } else {
                log.trace "No camera arm actions configured for Stay"
            }

            if (shmDisarmStay) {
                getChildDevices().each { device ->
                    if (shmDisarmStay.contains(device.displayName)) {
                        log.trace "Disabling ${device.displayName} Camera Motion Detection on Stay"
                        device.deferredLoopbackQueue(1, "disableAlerts") // Do it offline other the app times out with large number of cameras
                    } else {
                        log.trace "No disarm action defined for ${device.displayName} on Stay"
                    }
                }
            } else {
                log.trace "No camera disarm actions configured for Stay"
            }
	        break

        case "away":
            if (shmArmAway) {
                getChildDevices().each { device ->
                    if (shmArmAway.contains(device.displayName)) {
                        log.trace "Enabling ${device.displayName} Camera Motion Detection on Away"
                        device.deferredLoopbackQueue(1, "enableAlerts") // Do it offline other the app times out with large number of cameras
                    } else {
                        log.trace "No arm action defined for ${device.displayName} on Away"
                    }
                }
            } else {
                log.trace "No camera arm actions configured for Away"
            }

            if (shmDisarmAway) {
                getChildDevices().each { device ->
                    if (shmDisarmAway.contains(device.displayName)) {
                        log.trace "Disabling ${device.displayName} Camera Motion Detection on Away"
                        device.deferredLoopbackQueue(1, "disableAlerts") // Do it offline other the app times out with large number of cameras
                    } else {
                        log.trace "No disarm action defined for ${device.displayName} on Away"
                    }
                }
            } else {
                log.trace "No camera disarm actions configured for Away"
            }
            break

        case "off":
            if (shmDisarm) {
                getChildDevices().each { device ->
                    if (shmDisarm.contains(device.displayName)) {
                        log.trace "Disabling ${device.displayName} Camera Motion Detection on Disarm"
                        device.deferredLoopbackQueue(1, "disableAlerts") // Do it offline other the app times out with large number of cameras
                    } else {
                        log.trace "No action defined for ${device.displayName} on Disarm"
                    }
                }
            } else {
                log.trace "No camera actions configured for Disarm"
            }
	        break

        default:
            log.error "Invalid SHM state: $evt.value"
        break
    }
    
    kickStart(evt) // Kickstart incase timer died
}

// Start the motion check monitoring
def startMonitor(async = false) {
    log.trace "Start Monitor Called, start polling for motion events. Asynchronously: $async"

    if (!enablePollingEvents) {
        log.warn "Polling not enabled, not polling for motion events"
        return
    }

    if (!async) { // Do it right now in the current context
        checkForMotionEvents()
    } else { // Do it offline asynchronously to avoid platform timeout
        runIn (1, checkForMotionEvents) // Do it asynchronously to avoid timeout issues with the crappy platform
    }
}

// Stop the motion check monitoring
def stopMonitor(evt) {
    log.trace "Stop Monitor Called, stop polling for motion events"

    if (!enablePollingEvents) {
        log.warn "Polling not enabled, not polling for motion events"
        return
    }

    unschedule()
}

// MOTION DETECTION AND HEARTBEAT MONITORING
// To work around the stupid broken ST platform timers setup multiple level of mechanisms to poll for motion detection (i.e. heartbeat monitor for motion detection) (thanks for @copy-ninja for the idea)
def kickStart(evt) {
    log.trace "Kick start called by ${evt?.name}"

    if (!evt) {
        atomicState.lastHeartBeat = now() // Save the last time we scheduled motion event checks when not called by an event (i.e. heartbeat)
    }

    if (!enablePollingEvents) {
        log.warn "Polling not enabled, not polling for motion events"
        return
    }

    def monitorStatus = false
    def networkInfos = getNetworkInfo(null)
    if (networkInfos?.any {it.armed}) {
        log.trace "Global Monitor Armed"
        monitorStatus = true
    } else {
        log.trace "Global Monitor DisArmed"
        monitorStatus = false
    }

    if (monitorStatus) { // If the monitoring is active
        // Reschedule the motion detection check if didn't update for more than 1 minutes beyond the polling period
        log.trace "Last motion detection check was done " + ((now() - (atomicState.lastMotionMonitorCheck ?: 0))/(60*1000)) + " minutes ago"
        if ((((atomicState.lastMotionMonitorCheck ?: 0) + (pollPeriod() * 1000) + (1*60*1000)) < now()) && canSchedule()) {
            log.warn "Motion detection hasn't been run a long time, rescheduling it for every ${pollPeriod()/60} minutes"
            schedule("* */" + (pollPeriod()/60) + " * * * ?", startMonitor) // Schedule the monitor check
            startMonitor(true) // It died, start the checking for motion events, do it offline/deferred
        }

        if (evt) { 
            log.trace "Scheduling a backup motion detection scheduler in 11 minutes" 
            runIn((5+6)*60, backupMotionDetectionScheduler) // Schedule a backup in 11 minutes (since the heartbeat runs every 5 minutes give it some grace)
            startMonitor() // Just incase it died, start the checking for motion events, driven by an external event then do it synchronously
        }
    }
}

// Backup scheduler (incase the original is overloaded)
def backupMotionDetectionScheduler() { 
    log.trace "Backup Motion Detection Scheduler"
    startMonitor() // Do it in the current context don't defer it
}

// Check every 60 seconds for new motion events (60 is the minimum resolution that can run reliably on the platform)
private pollPeriod() {
    return 1*60 // This should be multiple of 60 for now (due to limitations of schedule in kickStart() for now
}

// Time to turn off motion sensor (for push notifications)
private motionOffPeriod() {
    return 1*60 // Set to 1 minute to make it reliable or can change later
}

def checkForMotionEvents() {
    log.trace "Called check for new motion events"

    if (!enablePollingEvents) {
        log.warn "Polling not enabled, not polling for motion events"
        return
    }

    atomicState.lastMotionMonitorCheck = now() // Update the last time we checked for motion events

    // Hack for broken ST timers - Schedule the KickStart schedule check motion events
    if (((atomicState.lastHeartBeat ?: 0) + ((5+5)*60*1000) < now()) && canSchedule()) { // Since we are scheduling the heartbeat every 5 minutes, give it a 5 minute grace
        log.warn "Heartbeat not called in last 10 minutes, rescheduling heartbeat"
        runEvery5Minutes(kickStart) // run the motion detection scheduler every 5 minutes (heartbeat)
        atomicState.lastHeartBeat = now() // give it 5 minutes before you schedule it again
    }

    try {
        // Optimize by checking if any devices are active before reaching out to the network
        def allDevices = getChildDevices() // Get all cameras
        if (!allDevices.any { device -> ["on", "alarm"].contains(device.currentValue("enableStatus")) }) { // If the camera motion alerts is disabled don't check for motion alerts
            log.trace "All cameras are currently disabled, skipping motion check"
            return // nothing to check
        }

        def networkIds = getAllArmedNetworkIDs()
        if (!networkIds) {
            log.error "Unable to get networkIDs"
            throw new RuntimeException("Unable to get networkIDs")  // lets try again later
        }

        for (networkId in networkIds) {
            def allEvents = []
            // Make this call just once, since it's per sync module and it's a very expensive operations and calling too many times can cause the shitty platform to timeout
            allEvents = getAllEventsForSyncModule(networkId, null)
            if (!allEvents) {
                log.error "Unable to get list of all events from sync module $networkId"
                throw new RuntimeException("Unable to get list of all events from sync module $networkId") // lets try again later
            }

            // Get check camera and check if we have events for them
            log.trace "Checking all cameras for motion events"
            allDevices.each {device ->
                checkCameraForMotionEvents(allEvents, networkId, device)
            }
        }
    } catch (e) {
        log.error "Error while trying to check for camera motion events : $e"
    } // If there is a timeout execption catch it so that we can continue scheduling timers and don't let the system die due to a crappy ST platform
}
// END MOTION DETECTION AND HEARTBEAT

// Check for any motion events since the last poll
def checkCameraForMotionEvents(allEvents, networkId, child) {
    log.trace "Checking Camera ${child?.device.displayName} for new motion events"
    //child?.log "Checking Camera ${child?.device.displayName} for new motion events"

    if (child.device.currentValue("enableStatus") == "off") { // If the camera motion alerts is disabled don't check for motion alerts
        log.trace "Skipping checking Camera ${child?.device.displayName} for new motion events as Camera Motion Alerts is currently disabled"
        //child?.log "Skipping checking Camera ${child?.device.displayName} for new motion events as Camera Motion Alerts is currently disabled"
        return true // no motion alerts here
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def events = []

    if (!allEvents) { // Incase we were sent with no events (e.g. sync module list broken), lets get the camera events ourselves
        allEvents = getAllEventsForCamera(networkId, cameraId, child)
        if (!allEvents) {
            log.error "Unable to get list of all events from camera $cameraId"
            //child?.log "Unable to get list of all events from camera $cameraId", "error"
        }
    }

    // Filter the motion events for a specific camera given all the events from a sync module
    def motionEvents = allEvents?.findAll { event -> (event.type == "motion") && (event.camera_id == (cameraId as Long)) } // THIS IS IT -> type=motion, created_at=XXX, id=XXX, camera_name=XXX
    //log.trace "Motion Events retrieved for Camera $cameraId:\n${motionEvents?.inspect()}"
    //log.trace "First Motion Event retrieved for Camera $cameraId:\n${motionEvents?.first().inspect()}"
    //log.trace "Last Motion Event retrieved for Camera $cameraId:\n${motionEvents?.last().inspect()}"
    //child?.log "Motion Events retrieved for Camera $cameraId:\n${motionEvents?.inspect()}"
    //child?.log "First Motion Event retrieved for Camera $cameraId:\n${motionEvents?.first().inspect()}"
    //child?.log "Last Motion Event retrieved for Camera $cameraId:\n${motionEvents?.last().inspect()}"
    if (!motionEvents) {
        log.trace "No motion events found for camera ${child?.device.displayName}"
        //child?.log "No motion events found for camera ${child?.device.displayName}"
        return true
    }

    // Now check to see if there are any new events since the last time we checked
    log.trace "Found ${motionEvents.size()} motion events for camera ${child?.device.displayName}"
    //child?.log "Found ${motionEvents.size()} motion events for camera ${child?.device.displayName}"
    for (motionEvent in motionEvents) {
        def dateTime = Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", motionEvent.created_at)
        //log.trace "Found motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"
        //child?.log "Found motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"

        if (atomicState."lastMotionCheck${cameraId}") { // Initialize if it hasn't been
            //log.trace "Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
            //child?.log "Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
        } else {
            log.warn "Last time motion event was never checked, initializing last time checked"
            //child?.log "Last time motion event was never checked, initializing last time checked", "warn"
            atomicState."lastMotionCheck${cameraId}" = now() // Set the initial reference to check for motion events, use atomicState when using across child/parent interfaces since child cannot update state variables
        }

        if (dateTime > (new Date(atomicState."lastMotionCheck${cameraId}"))) { // Check if this in a new event (since the last time we checked)
            log.debug "Found NEW motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
            //child?.log "Found NEW motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}", "debug"
            events << [name: "motion", value: "active", descriptionText: "${child?.device.displayName} detected a motion event"]
            events << [name: "enableStatus", value: "alarm"]
            child.deferredLoopbackQueue(pollPeriod() * 2, "turnOffMotionEvent", null, true) // Disable the motion sensor event in 2 x poll period (give it time to process multiple events if there are since we are checking every 60 seconds) (overwrite any existing requests)
            motionDetectedTakeActions(child)
            break // Process only one motion event to avoid multiple reports / conflicts (the camera can generate multiple events in succession)
        }
    }

    // Register all the events with the camera
    events ? child.generateEvent(events) : "" // Update the device status

    atomicState."lastMotionCheck${cameraId}" = now() // Update the last time we checked for new motion events
    //log.trace "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
    //child?.log "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"

    return true // all done
}

def motionDetectedTakeActions(child) {
    log.info "Motion detected in camera ${child.device.displayName}"

    // turn on the alarms
    log.debug "Turning on alarms $alarms, silent: $alarmSilent"
    alarmSilent ? alarms?.strobe() : alarms?.both()

    // turn on lights
    log.debug "Turning on lights $lights"
    lights?.on()
    if (lightTimer) {
        log.trace "Scheduling lights turn off after $lightTimer minutes"
        runIn(lightTimer * 60, turnOffLights)
    }

    // take picture
    if (picture) {
        log.debug "Taking a picture with camera ${child.device.displayName}"
        child.take()
    }

    // Send notifications
    def message = "${child.device.displayName} has detected motion"
    if (location.contactBookEnabled) {
        log.debug "Sending message to $recipients"
        sendNotificationToContacts(message, recipients)
    } else {
        log.debug "SMS: $sms, Push: $push"
        sms ? sendText(sms, message) : ""
        push ? sendPush(message) : sendNotificationEvent(message)
    }
}

def turnOffLights() {
    log.debug "Schedule called, turning off lights $lights"
    lights?.off()
}

private sendText(number, message) {
    if (number) {
        def phones = number.split("\\+")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}


// BLINK SERVER INTERFACES
// Blink REST Server
private loginServerURL() {
    return "https://rest.prod.immedia-semi.com"
}

// Dynamically build server, now servers are dynamic across the world
private serverURL(base) {
    return "https://rest." + base + ".immedia-semi.com"
}

// Logout of Blink (to destroy client create by Blink at login)
private logout(child) {
    def success = false

    if (!atomicState.authToken) {
        log.warn "No active token found, not logging out of Blink"
        //child?.log "No active token found, not logging out of Blink", "warn"
        return true // nothing to logout do we're good
    }

    try {
        log.debug "Logging out of Blink using token: ${atomicState.authToken}"
        //child?.log "Logging out of Blink using token: ${atomicState.authToken}", "debug"

        httpPost([
            uri: serverURL(atomicState.baseServer),
            path: "/logout",
            headers: atomicState.authToken
        ]) { ret ->
            if (ret.data) {
                //log.trace "RESPONSE>" + ret.data
                //child?.log "RESPONSE>" + ret.data
                if (ret.data.message == "logout") { // Is there a error/warning message from the Blink server
                    log.trace "Blink server successfully logged out client"
                    //child?.log "Blink server successfully logged out client"
                }
                success = true
            } else {
                log.error "No response to logout request: $ret.data"
                //child?.log "No response to logout request: $ret.data", "error"
            }
        }
    } catch (e) {
        log.warn "Unable to logout, likely no active tokens: $e" // don't try to get status as it thorws an error
        //child?.log "Unable to logout, likely no active tokens: $e", "warn"
    }

    atomicState.authToken = [] // We have no valid auth token now, reset it
    atomicState.baseServer = null //We have no valid base server now, reset it

    return success
}

// Login and return the Auth Token to use for calls
private login(child) {
    logout(child) // Logout before logging to clean up clients if they exist

    def authToken = null // Start with no authtoken since we have logged out
    def baseServer = null // Start with no base server since we have logged out
    def regionType = null // Start with no region
    def URL = enablePollingEvents ? "" : getCallBackURL(child) // Get callback URL to register with Blink when not using polling (only from SmartApp context, device context should be empty because there should be no accesstoken)
    def userAgent = "SmartThings ${clientVersion()} ${releaseTimeStamp()}"

    try {
        log.trace "Performing login and getting authentication token"
        //child?.log "Performing login and getting authentication token"
        httpPost(
            [
                uri: loginServerURL(),
                path: "/login",
                headers: ['User-Agent': userAgent],
                body: [
                    email: blinkLogin,
                    password: blinkPassword,
                    client_specifier: "SmartThings Client | ${clientVersion()}",
                    client_type: "smartthings",
                    notification_key: URL
                ]
            ]
        ) { ret ->
            //log.trace "Received authentication response: $ret.data"
            //child?.log "Received authentication response: $ret.data"
            if (ret.data?.authtoken?.authtoken && ret.data?.region) {
                authToken = ret.data.authtoken.authtoken

                if (ret.data.region.size() != 1) {
                    log.error "INVALID LOGIN RESPONSE, received invalid region: $ret.data"
                    //child?.log "INVALID LOGIN RESPONSE, received invalid region: $ret.data", "error"
                    throw new RuntimeException("Invalid region received") // Lets not continue with out this settings
                }

                ret.data.region.each { server, region ->
                    baseServer = server
                    regionType = region
                }
                //log.trace "Received authentication token: $authToken, region: $region"
                //child?.log "Received authentication token: $authToken, region: $region"
            } else {
                log.error "Login failed, response: $ret.data"
                child?.log "Login failed, response: $ret.data", "error"
                authToken = baseServer = regionType = null
            }
        }
    } catch (e) {
        log.error "Exception during login: $e" // don't try to get status as it thorws an error
        //child?.log "Exception during login: $e", "error"
        authToken = baseServer = regionType = null
    }

    if (authToken) {
        atomicState.authToken = [ TOKEN_AUTH: authToken ] // Save it for use until it expires
        atomicState.baseServer = baseServer // We have a valid base server now, save it
        cleanUpSTClients(child) // Get rid of inactive clients so we don't need unnecessary notifications (only if we have authenticated)
    } else {
        atomicState.authToken = [] // We don't have a token
        atomicState.baseServer = null // We have no valid base server now, reset it
    }


    log.debug "Got new AuthToken = $atomicState.authToken, BaseServer = $atomicState.baseServer, Region = $regionType"
    //child?.log "Got new AuthToken = $atomicState.authToken, BaseServer = $atomicState.baseServer, Region = $regionType", "debug"

    return atomicState.authToken
}

// Query Blink Account
private queryBlink(path, child = null) {
    def response = null
    try {
        log.trace "Querying Blink: $path"
        //child?.log "Querying Blink: $path"
        //log.warn "Saved Auth Token: $atomicState.authToken, BaseServer = $atomicState.baseServer" // DEBUG
        //child?.log "Saved Auth Token: $atomicState.authToken, BaseServer = $atomicState.baseServer", "warn" // DEBUG

        if (!atomicState.authToken || !atomicState.baseServer) {
            login(child) // Check if we have a valid authToken and baseServer
        }

        if (rateLimitExceeded(child?.device?.deviceNetworkId)) {
            log.warn "${child?.device?.displayName} Too many query commands in too short a time, dropping request"
            return null
        }
        
        httpGet([
            uri: serverURL(atomicState.baseServer),
            path: path,
            headers: atomicState.authToken
        ]) { ret ->
            //log.trace "Received response from camera to httpGet, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //child?.log "Received response from camera to httpGet, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //if (ret.status == 200) {
            //log.trace "RESPONSE>" + ret.headers.'Content-Type'
            //child?.log "RESPONSE>" + ret.headers.'Content-Type'
            //if(ret.headers.'Content-Type'.contains("image/jpeg")) { // If we have a picture store it directly
            //log.trace "Got JPEG IMAGE"
            //child?.log "Got JPEG IMAGE"
            //}
            //}

            if (ret.data) {
                //log.trace "RESPONSE>" + ret.data
                //child?.log "RESPONSE>" + ret.data
                response = ret.data
            } else {
                log.error "No response to query: $ret.data"
                //child?.log "No response to query: $ret.data", "error"
            }
        }
    } catch (e) {
        log.error "Exception while querying: $e with status $e.response.status"
        //child?.log "Exception while querying: $e with status $e.response.status", "error"
        if ((e.response.status == 401) && (e.response.data?.message == "Unauthorized Access")) { // Check if the token has expired or invalid
            try {
                log.warn "Authentication token has expired, logging in again and getting new authentication token"
                //child?.log "Authentication token has expired, logging in again and getting new authentication token", "warn"
                login(child)
                return queryBlink(path, child) // Lets try it again
            } catch (f) {
                log.error "Exception while getting new authentication token: $f"
                //child?.log "Exception while getting new authentication token: $f", "error"
            }
        }
    }

    return response
}

// Send Command to Blink Account
private configureBlink(path, child = null, params = []) {
    def response = null
    try {
        log.trace "Configuring Blink: $path${params ? " with params $params" : ""}"
        //child?.log "Configuring Blink: $path${params ? " with params $params" : ""}"
        //log.warn "Saved Auth Token: $atomicState.authToken, BaseServer = $atomicState.baseServer" // DEBUG
        //child?.log "Saved Auth Token: $atomicState.authToken, BaseServer = $atomicState.baseServer", "warn" // DEBUG

        if (!atomicState.authToken || !atomicState.baseServer) {
            login(child) // Check if we have a valid authToken and baseServer
        }

        if (rateLimitExceeded(child?.device?.deviceNetworkId)) {
            log.warn "${child?.device?.displayName} Too many configuration commands in too short a time, dropping request"
            return null
        }
        
        httpPost([
            uri: serverURL(atomicState.baseServer),
            path: path,
            headers: atomicState.authToken,
            body: params
        ]) { ret ->
            if (ret.data) {
                //log.trace "RESPONSE>" + ret.data
                //child?.log "RESPONSE>" + ret.data
                if (ret.data.message) { // Is there a error/warning message from the Blink server
                    log.warn "Blink server response to configuration request: $ret.data.message"
                    //child?.log "Blink server response to configuration request: $ret.data.message", "warn"
                }
                response = ret.data
            } else {
                log.error "No response to configuration request: $ret.data"
                //child?.log "No response to configuration request: $ret.data", "error"
            }
        }
    } catch (e) {
        log.error "Exception while configuring: $e with status $e.response.status"
        //child?.log "Exception while configuring: $e with status $e.response.status", "error"
        if ((e.response.status == 401) && (e.response.data?.message == "Unauthorized Access")) {
            try {
                log.warn "Authentication token has expired, logging in again and getting new authentication token"
                //child?.log "Authentication token has expired, logging in again and getting new authentication token", "warn"
                login(child)
                return configureBlink(path, child) // Lets try it again
            } catch (f) {
                log.error "Exception while getting new authentication token: $f"
                //child?.log "Exception while getting new authentication token: $f", "error"
            }
        }
    }

    return response
}

private cleanUpSTClients(child) {
    return // TODO: implement cleaning of clients (check for clients with URL and expired token/old create dates and not udpated

    log.trace "Cleaning up expired SmartThings clients"
    //child?.log "Cleaning up expired SmartThings clients"

    def stClients = getActiveSTClients(child)
    if (!stClients) {
        log.warn "No ST clients found"
        //child?.log "No ST clients found", "warn"
        return
    }
}

// Get the list of registered SmartThings clients
private getActiveSTClients(child) {
    log.trace "Getting list of active SmartThings clients"
    //child?.log "Getting list of active SmartThings clients"

    def stClients = []
    try {
        def info = queryBlink("/account/clients", child)
        //log.trace "Active ST Clients raw: $info"
        //child?.log "Active ST Clients raw: $info"
        stClients = info?.clients?.findAll { client -> client.client_specifier.contains("SmartThings") } // Isolate the ST clients only
        //log.trace "Active ST Clients found: $stClients"
        //child?.log "Active ST Clients found: $stClients"
        def stClientsURL = stClients?.findAll { client -> client.notification_key }
        log.warn "Total Active ST Clients found: ${stClients?.size()}, with URL: ${stClientsURL?.size()}"
        //child?.log "Total Active ST Clients found: ${stClients?.size()}, with URL: ${stClientsURL?.size()}", "warn"
        def urlClientDetails = stClientsURL?.collect { client ->
            "Active ST URL Clients, Created: ${Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", client.created_at).format("EEE MMM dd yyyy HH:mm z", location.timeZone)}, Updated: ${Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", client.updated_at).format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"
        }?.join("\n")
        log.warn "${urlClientDetails}"
        //child?.log "${urlClientDetails}", "warn"
    } catch (e) {
        log.error "Unable to get ST clients: $e"
        //child?.log "Unable to get ST clients: $e", "error"
    }

    return stClients
}

// BLINK SERVER BUILDING BLOCKS
// Check if the command has been successfully completed
private getCommandStatus(networkId, commandId, child) {
    log.trace "Getting state of command: $commandId"
    //child?.log "Getting state of command: $commandId"

    if (!commandId) {
        log.warn "Not querying command status, invalid command id: $commandId"
        //child?.log "Not querying command status, invalid command id: $commandId", "warn"
        return false
    }

    def completed = false
    def info = queryBlink("/network/$networkId/command/$commandId", child)
    //log.trace info
    //child?.log info
    try {
        if (info.status_msg == "Command succeeded") {
            completed = true
        }
        log.trace "Command result: $info.status_msg"
        //child?.log "Command result: $info.status_msg"
    } catch (e) {
        log.error "Unable to get command status: $e"
        //child?.log "Unable to get command status: $e", "error"
        completed = false
    }

    return completed
}

// Get all sync module network IDs
private getAllNetworkIDs(child) {
    log.trace "Getting all Sync Module network ID"
    //child?.log "Getting all Sync Module network ID"

    def networkIds = []
    try {
        def info = queryBlink("/networks", child)
        networkIds = info.networks.collect { it.id }

        log.trace "All sync module NetworkIDs: $networkIds"
        //child?.log "All sync module NetworkIDs: $networkIds"
    } catch (e) {
        log.error "Unable to get all network ids: $e"
        //child?.log "Unable to get all network ids: $e", "error"
    }

    return networkIds
}

// Get all sync module network IDs which are armed
private getAllArmedNetworkIDs(child) {
    log.trace "Getting all armed Sync Module network ID"
    //child?.log "Getting all armed Sync Module network ID"

    def networkIds = []
    try {
        def info = queryBlink("/networks", child)
        networkIds = info.networks.findAll { it.armed } .collect { it.id }

        log.trace "All sync module NetworkIDs: $networkIds"
        //child?.log "All sync module NetworkIDs: $networkIds"
    } catch (e) {
        log.error "Unable to get all network ids: $e"
        //child?.log "Unable to get all network ids: $e", "error"
    }

    return networkIds
}

// Get the sync module network ID for a child device
private getNetworkID(child) {
    log.trace "Getting ${child.device.displayName} Sync Module network ID"
    //child?.log "Getting ${child.device.displayName} Sync Module network ID"

    if (!child) {
        throw new RuntimeException("No child device specified") // Lets not continue with out this settings
    }

    def networkId = atomicState."networkID${child.device.deviceNetworkId}"
    if (!networkId) {
        log.warn "${child.device.displayName} unable to get saved network id, trying to query camera network id"
        //child?.log "${child.device.displayName} unable to get saved network id, trying to query camera network id", "warn"
        def cameras = getBlinkCamerasList()
        networkId = cameras?.find { camera -> camera.id == child.device.deviceNetworkId }?.network
        if (!networkId) {
            log.error "${child.device.displayName} unable to query network id"
            //child?.log "${child.device.displayName} unable to query network id", "error"
        } else {
            atomicState."networkID${child.device.deviceNetworkId}" = networkId // Save networkId of Camera for future (performance improvement, each call to Blink is 2-3 seconds) and this is the most used call
        }
    } else {
        log.trace "${child.device.displayName} saved sync module NetworkID: $networkId"
        //child?.log "${child.device.displayName} saved sync module NetworkID: $networkId"
    }

    return networkId
}

// Check if the sync module is online and if so return sync module network ID
private isSyncModuleOnlineGetID(child) {
    log.trace "Getting Sync Module network ID for Camera ${child.device.displayName}"
    //child?.log "Getting Sync Module network ID for Camera ${child.device.displayName}"

    def networkId = null
    try {
        def childNetworkId = getNetworkID(child) // Get the child network id
        if (!childNetworkId) {
            log.error "Unable to get networkID"
            //child?.log "Unable to get networkID", "error"
            return networkId
        }

        def info = queryBlink("/network/$childNetworkId", child) // Get the network status
        if (info.network.sync_module_error) {
            log.warn "SYNC MODULE ${info.network.name} IS OFFLINE!"
            //child?.log "SYNC MODULE ${info.network.name} IS OFFLINE!", "warn"

            // Let the device handler know so it can update the tiles
            def events = []
            events << [name:"monitorStatus", value: "offline", displayed: true] // Show it on the logs
            child.generateEvent(events) // Update the device status
            if (!atomicState."syncOfflineMessageSent${childNetworkId}") { // Send a sync module offline message once per offline event
                sendPush "Blink Sync Module ${info.network.name} is offline, please check sync module network connection and power supply"
                atomicState."syncOfflineMessageSent${childNetworkId}" = true // We've sent the message
            }
        } else {
            networkId = childNetworkId
            log.trace "Sync module ${info.network.name} NetworkID: $networkId"
            //child?.log "Sync module ${info.network.name} NetworkID: $networkId"
            atomicState."syncOfflineMessageSent${childNetworkId}" = false // We are back online
        }
    } catch (e) {
        log.error "Unable to get network id: $e"
        //child?.log "Unable to get network id: $e", "error"
    }

    return networkId
}

// Return map with camera 'name', 'id' and 'network'
private getBlinkCamerasList(child) {
    log.trace "Getting Cameras List"
    //child?.log "Getting Cameras List"

    def cameras = []
    def networkIds = getAllNetworkIDs(child)
    for (networkId in networkIds) {
        def info = queryBlink("/network/$networkId/homescreen", child)
        info?.devices.each { device ->
            if (device.device_type == "camera") {
                log.trace "Found Camera $device.name with Id $device.device_id and Network $networkId"
                //child?.log "Found Camera $device.name with Id $device.device_id and Network $networkId"
                cameras << [name: device.name, id: device.device_id as String, network: networkId] // Save just the camera name, id and network
            }
        }
    }

    //log.trace cameras
    //child?.log cameras
    return cameras
}

// Return map with all cameras summary (camera id is stored under device_id)
private getAllCamerasSummary(child) {
    log.trace "Getting Cameras Summary"
    //child?.log "Getting Cameras Summary"

    def cameras = []
    def networkIds = getAllNetworkIDs(child)
    for (networkId in networkIds) {
        def info = queryBlink("/network/$networkId/homescreen", child)
        info?.devices.each { device ->
            if (device.device_type == "camera") {
                log.trace "Found Camera $device.name with Id $device.device_id and Network $networkId"
                //child?.log "Found Camera $device.name with Id $device.device_id and Network $networkId"
                cameras << device // Add it to the list
            }
        }
    }

    //log.trace cameras
    //child?.log cameras
    return cameras
}

// Get all cameras detailed information
private getAllCamerasDetails(networkId, child) {
    log.trace "Getting All Cameras Details"
    //child?.log "Getting All Cameras Details"

    def cameras = queryBlink("/network/$networkId/cameras", child)
    //log.trace cameras
    //child?.log cameras

    if (!cameras?.devicestatus) {
        log.error "Error: Blink returned:$cameras"
        //child?.log "Error: Blink returned:$cameras", "error"
    }

    return cameras?.devicestatus
}

// Get specific camera information
private getCameraDetails(networkId, cameraId, child) {
    log.trace "Getting Camera $cameraId Details"
    //child?.log "Getting Camera $cameraId Details"

    def camera = queryBlink("/network/$networkId/camera/$cameraId", child)
    //log.trace camera.camera_status.inspect()
    //child?.log camera.camera_status.inspect()

    if (!camera?.camera_status) {
        log.error "Error: Blink returned:$camera"
        //child?.log "Error: Blink returned:$camera", "error"
    }

    return camera?.camera_status
}

// Get specific camera configuration
private getCameraConfig(networkId, cameraId, child) {
    log.trace "Getting Camera $cameraId Configuration"
    //child?.log "Getting Camera $cameraId Configuration"

    def camera = queryBlink("/network/$networkId/camera/$cameraId/config", child)
    //log.trace camera.camera[0].inspect().substring(0,2000) // Doesn't fit in one line so split it
    //child?.log camera.camera[0].inspect().substring(0,2000) // Doesn't fit in one line so split it
    //log.trace camera.camera[0].inspect().substring(2000)
    //child?.log camera.camera[0].inspect().substring(2000)

    if (!camera?.camera[0]) {
        log.error "Error: Blink returned:$camera"
        //child?.log "Error: Blink returned:$camera", "error"
    }

    return camera?.camera[0]
}

// Get specific camera signals information
private getCameraSignalDetails(networkId, cameraId, child) {
    log.trace "Getting Camera $cameraId Signal Details"
    //child?.log "Getting Camera $cameraId Signal Details"

    def signal = queryBlink("/network/$networkId/camera/$cameraId/signals", child)
    //log.trace signal.inspect()
    //child?.log signal.inspect()

    return signal
}

// Get details of all videos taken from the camera currently on the cloud
private getCameraVideoDetails(networkId, cameraId, child) {
    log.trace "Getting All Videos Details for Camera ID $cameraId"
    //child?.log "Getting All Videos Details for Camera ID $cameraId"

    def videos = queryBlink("/network/$networkId/camera/$cameraId/videos/unwatched", child)

    if (!videos?.video) {
        log.error "Error: Blink returned:$videos"
        //child?.log "Error: Blink returned:$videos", "error"
    }

    return videos?.video
}

// Get the all sync modules network details
private getNetworkInfo(child) {
    log.trace "Getting all Sync modules Network Info"
    //child?.log "Getting all Sync modules Network Info"

    def networkInfo = []
    def info = queryBlink("/networks", child)
    networkInfo = info?.networks

    //log.trace "NETWORK INFO>" + networkInfo
    //child?.log "NETWORK INFO>" + networkInfo
    return networkInfo
}

// Get all the events for a sync module and all it's connected cameras
private getAllEventsForSyncModule(networkId, child) {
    log.trace "Getting All Events for Sync Module $networkId"
    //child?.log "Getting All Events for Sync Module $networkId"

    // NOTE: This is a very heavy time consuming call
    //def events = queryBlink("/events", child) // Returns the last 200 events from the camera
    def events = queryBlink("/events/network/$networkId", child) // Returns the last 100 events from the camera
    //log.trace "All Events retrieved:\n${events.event.inspect()}"
    //child?.log "All Events retrieved:\n${events.event.inspect()}"

    if (!events?.event) {
        log.error "Error: Blink returned:$events"
        //child?.log "Error: Blink returned:$events", "error"
    }

    return events?.event
}

// Get all the events for a camera
private getAllEventsForCamera(networkId, cameraId, child) {
    log.trace "Getting All Events for camera $cameraId"
    //child?.log "Getting All Events for camera $cameraId"

    // NOTE: This is a very heavy time consuming call
    def events = queryBlink("/events/network/$networkId/camera/$cameraId", child) // Returns the last 100 events from the camera
    //log.trace "All Camera Events retrieved:\n${events.event.inspect()}"
    //child?.log "All Camera Events retrieved:\n${events.event.inspect()}"

    if (!events?.event) {
        log.error "Error: Blink returned:$events"
        //child?.log "Error: Blink returned:$events", "error"
    }

    return events?.event
}


// Check if monitor is enabled and if not then enable it
private Boolean checkAndEnableMonitorStatus(child)
{
    // Before you can change motion alerts for a camera, global monitoring must be enabled or Blink will reject the command
    if (child.device.currentValue("monitorStatus") == "off") { // If we are currently in an alarm active state
        log.trace "Global monitoring off, enabling global monitoring before changing camera motion alerts status"
        //child?.log "Global monitoring off, enabling global monitoring before changing camera motion alerts status"
        return monitorOn(child)
    } else {
        return true
    }
}

// OAUTH STUFF
// OAuth Configuration for Push Camera incoming Web notifications
mappings {
    path("/Blink") {
        action: [
            GET: "cameraCallback",
            POST: "cameraCallback"
        ]
    }
}

// OAuth call back from external REST webservice
def cameraCallback() {
    log.trace "Received event callback\nBlink -> $params\nAmazon -> $request.JSON"

    def type
    def cameraId
    def token = params.access_token

    if (request.JSON?.Type == "SubscriptionConfirmation") { // Amazon SNS required confirmation for subscription event before it will send notifications
        def subscribeURL = request.JSON?.SubscribeURL
        log.trace "Subscribing to Amazon request URL: $subscribeURL"

        try {
            httpGet([
                uri: subscribeURL
            ]) { ret ->
                log.trace "Amazon subscription confirmation, headers=${ret.headers.'Content-Type'}, status=$ret.status"

                if (ret.status == 200) {
                    if (ret.data) {
                        log.trace "RESPONSE>" + ret.data
                    } else {
                        log.error "No response to query: $ret.data"
                    }
                } else {
                    log.error "Amazon subscription failed with message $ret.data"
                }
            }
        } catch (e) {
            log.error "Exception while querying: $e with status ${e.response.status} and message ${e.response.data?.message}"
        }
        
        return // We're done here for subscription, now wait for notification
    }
    
    if (request.JSON?.Type == "Notification") { // Coming from Amazon SNS
        def message = request.JSON?.Message
        if (message && (message instanceof String)) { // Sometimes Blink Amazon sends the message as a string which we need to convert to JSON
            log.trace "Got string from Amazon: $message"
            def options = new JsonSlurper().parseText(message)
            type = options?.category
            cameraId = options?.camera
        } else if (message) {
            log.trace "Got JSON from Amazon: $message"
            type = message?.category
            cameraId = message?.camera
        } else {
            log.warn "No content in Message from Blink Amazon"
        }
    } else { // Coming from legacy Blink
        type = params.type
        cameraId = params.camera
    }
    
    log.trace "Type ${type} for Camera Id ${cameraId}"

    if (token != state.accessToken) { // Make sure we're only receiving requests from the currently active access token
        log.error "Received event from an inactive client/token. Ignoring"
        return
    }

    if (!cameraId) {
        log.error "CameraId not specified for callback event, CANNOT proceed"
        return
    }

    def child = getChildDevice(cameraId)
    if(!child) {
        log.error "Received events from Unknown Camera with ID $cameraId"
        return
    }

    if (enablePollingEvents) {
        log.warn "Polling enabled, ignoring push motion events"
        //child?.log "Polling enabled, ignoring push motion events", "warn"
        return
    }

    if (child.device.currentValue("enableStatus") == "off") { // If the camera motion alerts is disabled don't check for motion alerts
        //child?.warn "Ignoring motion event from Camera ${child?.device.displayName} as Camera Motion Alerts is currently disabled"
        log.warn "Ignoring motion event from Camera ${child?.device.displayName} as Camera Motion Alerts is currently disabled"
        return // ignore motion alerts
    }

    switch (type) {
        case "motion": // This is a motion event
        def events = []
        def dateTime = new Date(now())
        log.debug "Got new motion event at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
        //child?.log "Got new motion event at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}", "debug"
        events << [name: "motion", value: "active", descriptionText: "${child?.device.displayName} detected a motion event"]
        events << [name: "enableStatus", value: "alarm"]
        child.deferredLoopbackQueue(motionOffPeriod(), "turnOffMotionEvent", null, true) // Disable the motion sensor event in a period (overwrite any existing requests)
        motionDetectedTakeActions(child)

        // Register all the events with the camera
        events ? child.generateEvent(events) : "" // Update the device status

        atomicState."lastMotionCheck${cameraId}" = now() // Update the last time we checked for new motion events incase we revert back to polled events
        //log.trace "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
        //child?.log "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
        break

        default:
            log.error "Unknown event of type $type received from camera $cameraId"
            //child?.log "Unknown event of type $type received from camera $cameraId", "error"
            break
    }

    return
}

private setupCallBackURL(child) {
    log.trace "Revoking old and Creating New Access Token for callback" // For security purposes each time we initialize we create a new token
    //child?.log "Revoking old and Creating New Access Token for callback" // For security purposes each time we initialize we create a new token

    try {
        revokeAccessToken() // First kill the old tokens
        createAccessToken() // Now create a new token
    } catch (e) {
        log.error "Error creating access token, have you ENABLED OAuth in the SmartApp Settings?"
        //child?.log "Error creating access token, have you ENABLED OAuth in the SmartApp Settings?", "error"
        sendPush "Error creating access token, have you ENABLED OAuth in the SmartApp Settings?"
        log.error "Error : $e"
        //child?.log "Error : $e", "error"
        return
    }

    // Each Camera will call this URL with their Id's
    //def callbackURL = "http://graph.api.smartthings.com/api/token/${state.accessToken}/smartapps/installations/${app.id}/Blink"
    //def callbackURL = apiServerUrl("/api/token/${state.accessToken}/smartapps/installations/${app.id}/Blink")
    def callbackURL = apiServerUrl("/api/smartapps/installations/${app.id}/Blink?access_token=${state.accessToken}") // New format per documentation

    log.trace "New Blink Callback URL -> $callbackURL"
    //child?.log "New Blink Callback URL -> $callbackURL"

    return
}

private getCallBackURL(child) {
    if (!state.accessToken) {
        log.error "No Access Token found for callback, no returning any callbackURL"
        //child?.log "No Access Token found for callback, no returning any callbackURL", "error"
        return ""
    }

    // Each Camera will call this URL with their Id's
    //def callbackURL = "http://graph.api.smartthings.com/api/token/${state.accessToken}/smartapps/installations/${app.id}/Blink"
    //def callbackURL = apiServerUrl("/api/token/${state.accessToken}/smartapps/installations/${app.id}/Blink")
    def callbackURL = apiServerUrl("/api/smartapps/installations/${app.id}/Blink?access_token=${state.accessToken}") // New format per documentation

    log.trace "Getting Blink Callback URL -> $callbackURL"
    //child?.log "Getting Blink Callback URL -> $callbackURL"

    return callbackURL
}



// UPDATE STATUS METHODS WITH DEFERRED RETRY INTERFACES
// Get and update Image of camera
def Boolean updateCameraImage(child, retryCount = 1) {
    log.trace "Getting Camera Image for ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Getting Camera Image for ${child?.device.displayName}"

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    // Get details of the camera device from which the request has come
    def camera = getCameraDetails(networkId, cameraId, child)
    if (!camera) {
        log.error "Unable to get camera details"
        //child?.log "Unable to get camera details", "error"
        return false
    }

    def imageURL = camera.thumbnail
    log.debug "Got camera $cameraId -> Image $imageURL"
    //child?.log "Got camera $cameraId -> Image $imageURL", "debug"

    //Now retrieve the image
    def image = queryBlink(imageURL + ".jpg", child)
    //log.trace image.inspect()
    //child?.log image.inspect()

    // Now save the image from the device context
    child.saveImage(image)

    return true // all done
}

// Get and update all sensor parameters of camera (Wifi, Signal, Temperature, Battery)
def Boolean updateCameraSensorStatus(child, retryCount = 1) {
    log.trace "Getting Camera Sensor Status for ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Getting Camera Sensor Status for ${child?.device.displayName}"

    def events = []

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def camera = getCameraDetails(networkId, cameraId, child) // For battery and temperature
    if (!camera) {
        log.error "Unable to get camera details"
        //child?.log "Unable to get camera details", "error"
        return false
    }

    //def signal = getCameraSignalDetails(networkId, cameraId, child) // For standardized signal levels
    //if (!signal) {
    //    log.error "Unable to get camera signal details"
        //child?.log "Unable to get camera signal details", "error"
    //    return false
    //}

    // Get the camera Battery status
    def battery = camera.battery_level as Float
    log.trace "Got camera $camera.camera_id -> raw battery level ${battery.round()}, ${(battery*0.02).round(2)}v"
    //child?.log "Got camera $camera.camera_id -> raw battery level ${battery.round()}, ${(battery*0.02).round(2)}v"
    battery = ((battery - 110) / (1.70 - 1.10)).round() // Max battery level is 170 (3.4v) and dead battery level is 110 (2.2v) (http://data.energizer.com/PDFs/lithiuml91l92_appman.pdf)
    battery = Math.min(battery, 100) // don't let it exceed 100%
    battery = Math.max(battery, 1) // don't let fall below 1% (no exact camera cut off voltage, could be lower than 2.5v)
    log.debug "Camera $camera.camera_id -> Battery $battery%"
    //child?.log "Camera $camera.camera_id -> Battery $battery%", "debug"
    events << [name:"battery", value:battery]

    // Get the camera temperature status
    def temperature = camera.temperature
    def unit = "F"
    log.debug "Got camera $camera.camera_id -> Temperature ${temperature} F"
    //child?.log "Got camera $camera.camera_id -> Temperature ${temperature} F", "debug"
    if (location.temperatureScale != "F") { // If it isnt F we need to convert it to C as Blink reports in F
        temperature = (((temperature as Float) - 32) * 5 / 9).round() as Integer // C = (F-32)/9
        unit = "C"
        log.debug "Converted Temperature from F to C -> ${temperature} C"
        //child?.log "Converted Temperature from F to C -> ${temperature} C", "debug"
    }
    events << [name:"temperature", value:temperature, unit: unit]

    // Get the Camera WiFi signal status
    //def wifi = signal.wifi
    //log.debug "Got camera $camera.camera_id -> WiFi strength $wifi"
    //child?.log "Got camera $camera.camera_id -> WiFi strength $wifi", "debug"
    //events << [name:"wifi", value:wifi]

    // Get the Camera LFR signal status
    //def lfr = signal.lfr
    //log.debug "Got camera $camera.camera_id -> LFR strength $lfr"
    //child?.log "Got camera $camera.camera_id -> LFR strength $lfr", "debug"
    //events << [name:"lfr", value:lfr]

    // Get last time the sensor data was updated
    def lastUpdate = camera.updated_at
    log.trace "Got camera $camera.camera_id -> Last sensor update $lastUpdate"
    //child?.log "Got camera $camera.camera_id -> Last sensor update $lastUpdate"
    def dateTime = Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", lastUpdate)
    log.debug "Last sensor update ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"
    //child?.log "Last sensor update ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}", "debug"
    def strUpdate = dateTime.format("EEE MMM dd", location.timeZone) + "\n " + dateTime.format("HH:mm z", location.timeZone)
    events << [name:"lastUpdate", value:strUpdate]    

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true // all done
}

// Get and update Motion Alerts status of Camera
def Boolean updateCameraMotionAlertsStatus(child, retryCount = 1) {
    log.trace "Getting Camera Motion Alerts Status for ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Getting Camera Motion Alerts Status for ${child?.device.displayName}"

    def events = []

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    // Get details of the camera device from which the request has come
    def allCameras = getAllCamerasSummary(child) // For camera names and alert status
    if (!allCameras) {
        log.error "Unable to get all cameras details"
        //child?.log "Unable to get all cameras details", "error"
        return false
    }

    // Get the Camera Motion Alerts Status
    def enabled = allCameras.find{it.device_id == (cameraId as Long)}?.enabled
    log.debug "Got camera ${child?.device.displayName} -> Motion Alerts enabled status $enabled"
    //child?.log "Got camera ${child?.device.displayName} -> Motion Alerts enabled status $enabled", "debug"
    if (enabled) {
        if (child.device.currentValue("motion") == "active") { // If we are currently in an alarm active state
            log.debug "Active Motion Sensor Alert in progress"
            //child?.log "Active Motion Sensor Alert in progress", "debug"
            if (!switchControlsSystem) { // If the switch controls the cameras instead of the system
                events << [name: "alarm", value: "both"]
                events << [name: "switch", value: "on"]
            }
            events << [name: "enableStatus", value: "alarm"]

        } else {
            if (!switchControlsSystem) { // If the switch controls the cameras instead of the system
                events << [name:"alarm", value:"both"]
                events << [name:"switch", value:"on"]
            }
            events << [name:"enableStatus", value:"on"]
        }
    } else {
        if (!switchControlsSystem) { // If the switch controls the cameras instead of the system
            events << [name:"alarm", value:"off"]
            events << [name:"switch", value:"off"]
        }
        events << [name:"enableStatus", value:"off"]
    }

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true // all done
}

// Get the camera configuration and update status
def updateCameraConfig(child, retryCount = 1) {
    log.trace "Getting Camera Configuration for ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Getting Camera Configuration for ${child?.device.displayName}"

    def events = []

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def camera = getCameraConfig(networkId, cameraId, child)
    if (!camera) {
        log.error "Unable to get camera config details"
        //child?.log "Unable to get camera config details", "error"
        return false
    }

    // Get the camera video recording length
    def length = camera.video_length
    log.debug "Got camera $camera.id -> Video Recording Length $length seconds"
    //child?.log "Got camera $camera.id -> Video Recording Length $length seconds", "debug"
    events << [name:"videoLength", value:length]
    
    // Get the camera motion sensitivity
    def sensitivity = camera.motion_sensitivity
    log.debug "Got camera $camera.id -> Motion Sensitivity $sensitivity"
    //child?.log "Got camera $camera.id -> Motion Sensitivity $sensitivity", "debug"
    events << [name:"motionSensitivity", value:sensitivity]
    
    // Get the camera retrigger time
    def interval = camera.alert_interval
    log.debug "Got camera $camera.id -> Video ReTrigger Interval $interval seconds"
    //child?.log "Got camera $camera.id -> Video ReTrigger Interval $interval seconds", "debug"
    events << [name:"retriggerTime", value:interval]
    
    // Get the illuminator LED state
    def led
    switch (camera.illuminator_enable) {
        case 0:
            led = "off"
            break

        case 1:
            led = "on"
            break

        case 2:
            led = "auto"
            break

        default:
            log.error "Invalid LED State $camera.illuminator_enable"
            //child?.log "Invalid LED State $camera.illuminator_enable", "error"
            led = "off"
            break
    }
    
    log.debug "Got camera $camera.id -> Illuminator LED State $led"
    //child?.log "Got camera $camera.id -> Illuminator LED State $led", "debug"
    events << [name:"ledStatus", value:led]

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true // all done
}

// Get and update status of Monitoring (Global level)
def Boolean updateMonitorStatus(child, retryCount = 1) {
    log.trace "Getting Global Monitor Update Status request from ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Getting Global Monitor Update Status request from ${child?.device.displayName}"

    def childDevices = getChildDevices()
    def monitorStatus
    def alarmSwitch
    def allCameras = getBlinkCamerasList(child)
    def networkInfos = getNetworkInfo(child)
    for (networkInfo in networkInfos) {
        if (networkInfo?.sync_module_error) {
            log.warn "Global Monitor SYNC MODULE OFFLINE for ${networkInfo.name}"
            //child?.log "Global Monitor SYNC MODULE OFFLINE for ${networkInfo.name}", "warn"
            monitorStatus = "offline"
            alarmSwitch = "off"
            if (!atomicState."syncOfflineMessageSent${networkInfo.id}") { // Send a sync module offline message once per event
                sendPush "Blink Sync Module ${networkInfo.name} is offline, please check sync module network connection and power supply"
                atomicState."syncOfflineMessageSent${networkInfo.id}" = true // We've sent the message
            }
        } else if (networkInfo?.armed) {
            log.debug "Global Monitor Armed for ${networkInfo.name}"
            //child?.log "Global Monitor Armed for ${networkInfo.name}", "debug"
            monitorStatus = "on"
            alarmSwitch = "on"
            atomicState."syncOfflineMessageSent${networkInfo.id}" = false // We're back online
        } else {
            log.debug "Global Monitor DisArmed for ${networkInfo.name}"
            //child?.log "Global Monitor DisArmed for ${networkInfo.name}", "debug"
            monitorStatus = "off"
            alarmSwitch = "off"
            atomicState."syncOfflineMessageSent${networkInfo.id}" = false // We're back online
        }

        // Monitoring is controlled at a global level for a sync module and its cameras so update all devices within the sync module
        allCameras.findAll {it.network == networkInfo.id} .each { camera ->
            def device = childDevices.find { it.deviceNetworkId == camera.id } // Find the matching child device for this camera
            if (!device) {
                log.error "Cannot find child camera device with Id ${camera.id}"
                //child?.log "Cannot find child camera device with Id ${camera.id}", "error"
            } else {
                log.trace "Updating Sync module status for child camera device ${device.displayName}"
                //child?.log "Updating Sync module status for child camera device ${device.displayName}"

                def events = []
                if (switchControlsSystem) { // If the switch controls the system instead of the camera
                    events << [name:"alarm", value: alarmSwitch]
                    events << [name:"switch", value: alarmSwitch]
                }
                if (monitorStatus == "off") { // If the SM has been turned off, then disable any stuck motion detection notifications
                    events << [name: "motion", value: "inactive", descriptionText: "${device.displayName} motion stopped"] // Disable the motion event (if stuck)
                    if (device.currentValue("enableStatus") == "alarm") { // Reset the status to on if it's stuck in alarm state
                        events << [name: "enableStatus", value: "on"]
                    }
                }
                events << [name:"monitorStatus", value: monitorStatus]

                device.generateEvent(events) // Update the device status
            }
        }
    }

    return true
}

// Disable the motion event
def turnOffMotionEvent(child, retryCount = 1) {
    log.trace "Turning off Camera ${child?.device.displayName} motion events, retryCount $retryCount"
    //child?.log "Turning off Camera ${child?.device.displayName} motion events"

    def events = []

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    // Get details of the camera device from which the request has come
    def allCameras = getAllCamerasSummary(child) // For camera names and alert status
    if (!allCameras) {
        log.error "Unable to get all cameras details"
        //child?.log "Unable to get all cameras details", "error"
        return false
    }

    // Get the Camera Motion Alerts Status
    def enabled = allCameras.find{it.device_id == (cameraId as Long)}?.enabled
    log.debug "Got camera ${child?.device.displayName} -> Motion Alerts enabled status $enabled"
    //child?.log "Got camera ${child?.device.displayName} -> Motion Alerts enabled status $enabled", "debug"

    if (enabled) { // If the alerts are active then switch is on and alarm is both
        events << [name: "motion", value: "inactive", descriptionText: "${child?.device.displayName} motion stopped"]
        events << [name: "enableStatus", value: "on"]
    } else { // otherwise all off
        events << [name: "motion", value: "inactive", descriptionText: "${child?.device.displayName} motion stopped"]
        events << [name: "enableStatus", value: "off"]
    }

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true
}



// PARENT CHILD INTERFACES
// Enable live view and get URL
def String getLiveViewURL(child, retryCount = 1) {
    log.trace "Enable Live View and return URL called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Enable Live View and return URL called by ${child?.device.displayName}"

    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/liveview", child)
    if (ret != null) {
        log.trace "Successfully enabled live view, command Id: $ret.id, URL: $ret.server"
        //child?.log "Successfully enabled live view, command Id: $ret.id, URL: $ret.server"

        // If the command was successfully completed then return the URL
        if (getCommandStatus(networkId, ret.id, child)) {
            return ret.server
        } else {
            log.warn "Command not yet completed, live view may not work, try after a while"
            //child?.log "Command not yet completed, live view may not work, try after a while", "warn"
            return ret.server
        }
    } else if (enableRetry) {
        log.error "Failed to enable live view and get URL, possibly due to busy server. Try again after a while"
        //child?.log "Failed to enable live view and get URL, possibly due to busy server. Try again after a while", "error"
        return null
    }

    return null // something went wrong
}

// Turn off Illuminator LED
def Boolean ledOff(child, retryCount = 1) {
    log.trace "Turn off LED called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Turn off LED called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [illuminator_enable: 0])
    if (ret != null) {
        log.trace "Successfully sent turn off LED, command Id: $ret.id"
        //child?.log "Successfully sent turn off LED, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        log.warn "Failed to send turn off LED possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send turn off LED possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "ledOff", null, false, retryCount + 1) // If wasnt successful then try again after a while
        sent = false
    }

    return sent
}

// Turn on Illuminator LED
def Boolean ledOn(child, retryCount = 1) {
    log.trace "Turn on LED called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Turn on LED called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [illuminator_enable: 1])
    if (ret != null) {
        log.trace "Successfully sent turn on LED, command Id: $ret.id"
        //child?.log "Successfully sent turn on LED, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        log.warn "Failed to send turn on LED possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send turn on LED possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "ledOn", null, false, retryCount + 1) // If wasnt successful then try again after a while
        sent = false
    }

    return sent
}

// Turn Illuminator LED to Auto
def Boolean ledAuto(child, retryCount = 1) {
    log.trace "Turn LED to Auto called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Turn LED to Auto called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [illuminator_enable: 2])
    if (ret != null) {
        log.trace "Successfully sent turn LED to Auto, command Id: $ret.id"
        //child?.log "Successfully sent turn LED to Auto, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        log.warn "Failed to send turn LED to Auto possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send turn LED to Auto possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "ledAuto", null, false, retryCount + 1) // If wasnt successful then try again after a while
        sent = false
    }

    return sent
}

// Set the Retrigger time in seconds
def Boolean setRetriggerTime(child, interval, retryCount = 1) {
    log.trace "Set retrigger time to $interval, called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Set retrigger time to $interval, called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [alert_interval: interval as Integer])
    if (ret != null) {
        log.trace "Successfully sent set retrigger time, command Id: $ret.id"
        //child?.log "Successfully sent set retrigger time, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        log.warn "Failed to send Set retrigger time possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send Set retrigger time possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "setRetriggerTime", [interval], false, retryCount + 1) // If wasnt successful then try again after a while
        sent = false
    }

    return sent
}

// Set the Motion Detection Sensitivity
def Boolean setMotionSensitivity(child, sensitivity, retryCount = 1) {
    log.trace "Set motion sensitivity to $sensitivity, called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Set motion sensitivity to $sensitivity, called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [motion_sensitivity: sensitivity as Integer])
    if (ret != null) {
        log.trace "Successfully sent set motion sensitivity, command Id: $ret.id"
        //child?.log "Successfully sent set motion sensitivity, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        log.warn "Failed to send Set Motion Sensitivity possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send Set Motion Sensitivity possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "setMotionSensitivity", [sensitivity], false, retryCount + 1) // If wasnt successful then try again after a while
        sent = false
    }

    return sent
}

// Set the Video Recording Length in Seconds
def Boolean setVideoRecordingLength(child, length, retryCount = 1) {
    log.trace "Set video recording length to $length, called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Set video recording length to $length, called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [video_length: length as Integer])
    if (ret != null) {
        log.trace "Successfully sent set video recording length, command Id: $ret.id"
        //child?.log "Successfully sent set video recording length, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        log.warn "Failed to send Set Video Recording Length possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send Set Video Recording Length possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "setVideoRecordingLength", [length], false, retryCount + 1) // If wasnt successful then try again after a while
        sent = false
    }

    return sent
}

// Take a picture with the camera
def Boolean takePicture(child, retryCount = 1) {
    log.trace "Take picture with camera called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Take picture with camera called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/thumbnail", child)
    if (ret != null) {
        log.trace "Successfully sent Take Picture Request, command Id: $ret.id"
        //child?.log "Successfully sent Take Picture Request, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            log.trace "Waiting 10 seconds for camera to update Blink servers before getting picture"
            //child?.log "Waiting 10 seconds for camera to update Blink servers before getting picture"
            child.deferredLoopbackQueue(10, "updateCameraImage") // If was successful then give it time to complete
        } else {
            log.warn "Command not yet completed, will retry in 15 seconds"
            //child?.log "Command not yet completed, will retry in 15 seconds", "warn"
            child.deferredLoopbackQueue(15, "updateCameraImage") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        log.warn "Failed to send Take Picture Request possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send Take Picture Request possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "takePicture", null, false, retryCount + 1) // Retry if it wasn't successful
        sent = false
    }

    return sent
}

// Enable Camera Motion Alerts
def Boolean enableAlerts(child, retryCount = 1) {
    log.trace "Enable Camera Motion Alerts called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Enable Camera Motion Alerts called by ${child?.device.displayName}"

    // Santity check before changing alerts
    if (!checkAndEnableMonitorStatus(child)) {
        log.warn "Unable to enable Monitoring"
        //child?.log "Unable to enable Monitoring", "warn"
    }

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    // Update the last timestamp to check for new events to now (ignore any motion events before now for this camera)
    if (atomicState."lastMotionCheck${cameraId}") { // Initialize if it hasn't been
        //log.trace "Last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"
        //child?.log "Last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"
    } else {
        log.warn "Last time motion event was never checked, initializing last time checked"
        //child?.log "Last time motion event was never checked, initializing last time checked", "warn"
    }

    atomicState."lastMotionCheck${cameraId}" = now() // Set the initial reference to check for motion events
    log.trace "Resetting last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"
    //child?.log "Resetting last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"

    def ret = configureBlink("/network/$networkId/camera/$cameraId/enable", child)
    if (ret != null) {
        log.trace "Successfully sent Enable Camera Motion Alerts, command Id: $ret.id"
        //child?.log "Successfully sent Enable Camera Motion Alerts, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraMotionAlertsStatus(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraMotionAlertsStatus") // If wasnt successful then give it time to complete
        }

        // Start monitoring for any motion events
        startMonitor(true)
    } else if (enableRetry) {
        log.warn "Failed to send Enable Camera Motion Alerts possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send Enable Camera Motion Alerts possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "enableAlerts", null, false, retryCount + 1) // Retry if it wasn't successful
        sent = false
    }

    return sent
}

// Disable Camera Motion Alerts
def Boolean disableAlerts(child, retryCount = 1) {
    log.trace "Disable Camera Motion Alerts called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Disable Camera Motion Alerts called by ${child?.device.displayName}"

    // Santity check before changing alerts
    if (!checkAndEnableMonitorStatus(child)) {
        log.warn "Unable to enable Monitoring"
        //child?.log "Unable to enable Monitoring", "warn"
    }

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/disable", child)
    if (ret != null) {
        log.trace "Successfully sent Disable Camera Motion Alerts, command Id: $ret.id"
        //child?.log "Successfully sent Disable Camera Motion Alerts, command Id: $ret.id"
        sent = true

        def events = []
        events << [name: "motion", value: "inactive", descriptionText: "${child?.device.displayName} motion stopped"] // Disable the motion event (if stuck)
        child.generateEvent(events) // // Register all the events with the camera

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraMotionAlertsStatus(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraMotionAlertsStatus") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        log.warn "Failed to send Disable Camera Motion Alerts possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send Disable Camera Motion Alerts possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "disableAlerts", null, false, retryCount + 1) // Retry if it wasn't successful
        sent = false
    }

    return sent
}

// Turn on Monitoring (Globally)
def Boolean monitorOn(child, retryCount = 1) {
    log.trace "Monitor On called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Monitor On called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    // Update the last timestamp to check for new events to now (ignore any motion events before now for this camera)
    if (atomicState."lastMotionCheck${cameraId}") { // Initialize if it hasn't been
        //log.trace "Last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"
        //child?.log "Last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"
    } else {
        log.warn "Last time motion event was never checked, initializing last time checked"
        //child?.log "Last time motion event was never checked, initializing last time checked", "warn"
    }

    atomicState."lastMotionCheck${cameraId}" = now() // Set the initial reference to check for motion events
    log.trace "Resetting last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"
    //child?.log "Resetting last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"

    def ret = configureBlink("/network/$networkId/arm", child)
    if (ret != null) {
        log.trace "Successfully sent Monitor Arm, command Id: $ret.id"
        //child?.log "Successfully sent Monitor Arm, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new monitor status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateMonitorStatus(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateMonitorStatus") // If wasnt successful then give it time to complete
        }

        // Start monitoring for any motion events
        startMonitor(true)
    } else if (enableRetry) {
        log.warn "Failed to send Monitor Arm possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send Monitor Arm possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "monitorOn", null, false, retryCount + 1) // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Turn Monitoring off (global level)
def Boolean monitorOff(child, retryCount = 1) {
    log.trace "Monitor Off called by ${child?.device.displayName}, retryCount $retryCount"
    //child?.log "Monitor Off called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/disarm", child)
    if (ret != null) {
        log.trace "Successfully sent Monitor Disarm, command Id: $ret.id"
        //child?.log "Successfully sent Monitor Disarm, command Id: $ret.id"
        sent = true

        if (getCommandStatus(networkId, ret.id, child)) {
            updateMonitorStatus(child)
        } else {
            log.warn "Command not yet completed, will retry in 5 second"
            //child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateMonitorStatus") // If wasnt successful then give it time to complete
        }

        // Stop monitoring for any motion events
        stopMonitor()
    } else if (enableRetry) {
        log.warn "Failed to send Monitor Disarm possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send Monitor Disarm possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "monitorOff", null, false, retryCount + 1) // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Force camera to wake up and refresh it's sensor parameters
def Boolean forceCameraSensorUpdate(child, retryCount = 1) {
    log.trace "Forcing camera ${child?.device.displayName} to wake up and update sensor data, retryCount $retryCount"
    //child?.log "Forcing camera ${child?.device.displayName} to wake up and update sensor data"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        //child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        //child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/status", child)
    if (ret != null) {
        log.trace "Successfully sent Camera Refresh Request, command Id: $ret.id"
        //child?.log "Successfully sent Camera Refresh Request, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            log.trace "Waiting 10 seconds for camera to update Blink servers before getting status update"
            //child?.log "Waiting 10 seconds for camera to update Blink servers before getting status update"
            child.deferredLoopbackQueue(10, "updateCameraSensorStatus") // If wasnt successful then give it time to complete
        } else {
            log.warn "Command not yet completed, will retry in 15 seconds"
            //child?.log "Command not yet completed, will retry in 15 seconds", "warn"
            child.deferredLoopbackQueue(15, "updateCameraSensorStatus") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        log.warn "Failed to send Camera Refresh Request possibly due to busy server, retrying in 5 seconds"
        //child?.log "Failed to send Camera Refresh Request possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "forceCameraSensorUpdate", null, false, retryCount + 1) // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Refresh all camera parameters
def Boolean refresh(child, retryCount = 1) {
    log.trace "Refresh called by ${child.device.displayName}"
    //child?.log "Refresh called by ${child.device.displayName}"

    //log.warn "Access Token: ${state.accesstoken}"
    //child?.log "Access Token: ${state.accesstoken}", "warn"
    //getActiveSTClients(child) // DEBUG
    //log.warn "Access Token: ${state.accesstoken}"
    //child?.log "Access Token: ${state.accesstoken}", "warn"

    def status = updateMonitorStatus(child)
    log.trace "Refresh MonitorStatus: $status"
    //child?.log "Refresh MonitorStatus: $status"

    status = updateCameraMotionAlertsStatus(child)
    log.trace "Refresh CameraMotionAlertsStatus: $status"
    //child?.log "Refresh CameraMotionAlertsStatus: $status"

    status = updateCameraSensorStatus(child)
    log.trace "Refresh CameraSensorStatus: $status"
    //child?.log "Refresh CameraSensorStatus: $status"

    //status = updateCameraImage(child)
    //log.trace "Refresh GetImage: $status"
    //child?.log "Refresh GetImage: $status"

    //status = updateCameraConfig(child)
    //log.trace "Refresh GetCameraConfig: $status"
    //child?.log "Refresh GetCameraConfig: $status"

    if (enablePollingEvents) {
        kickStart() // Kick start the timer if it's dead
    }

    return true // we completed it successfully
}

// Refresh all cameras all parameters
def void refreshAll() {
    log.trace "RefreshAll called"
    getChildDevices().each { device ->
        //device?.log "RefreshAll called"
        device.deferredLoopbackQueue(3, "refresh") // Defer the refresh for each device to avoid a timeout while initializing
    }
}

// DEBUGGING INTERFACES
// Send a custom command (for DEBUGGING)
def Boolean customCommandConfigure(cmd, child) {
    log.debug "Custom command configure called by ${child?.device.displayName} with command -> $cmd"
    child?.log "Custom command configure called by ${child?.device.displayName} with command -> $cmd", "debug"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def command = cmd?.replaceAll(":network", networkId.toString()).replaceAll(":camera", cameraId.toString())
    log.debug "Configuring command -> $command"
    child?.log "Configuring command -> $command", "debug"

    if (!command) {
        log.error "No command to send"
        child?.log "No command to send", "error"
        return false
    }        

    def ret = configureBlink(command, child)
    if (ret != null) {
        log.debug "Successfully configured Custom Command:\n$ret"
        child?.log "Successfully configured Custom Command:\n$ret", "debug"
        sent = true

        // If the command was successfully completed
        if (getCommandStatus(networkId, ret.id, child)) {
            log.debug "Command was sent successfully"
            child?.log "Command was sent successfully", "debug"
        } else {
            log.warn "Command not yet completed"
            child?.log "Command not yet completed", "warn"
        }
    } else if (enableRetry) {
        log.error "Failed to configure custom command"
        child?.log "Failed to configure custom command", "error"
        sent = false
    }

    return sent
}

// Get a custom command (for DEBUGGING)
def Boolean customCommandQuery(cmd, child) {
    log.debug "Custom command query called by ${child?.device.displayName} with command -> $cmd"
    child?.log "Custom command query called by ${child?.device.displayName} with command -> $cmd", "debug"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        log.error "Unable to get networkID"
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        log.error "Unable to get camera ID"
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def command = cmd?.replaceAll(":network", networkId.toString()).replaceAll(":camera", cameraId.toString())
    log.debug "Querying command -> $command"
    child?.log "Querying command -> $command", "debug"

    if (!command) {
        log.error "No command to query"
        child?.log "No command to query", "error"
        return false
    }        

    def ret = queryBlink(command, child)
    if (ret != null) {
        log.debug "Successfully queried Custom Command, response:"
        child?.log "Successfully queried Custom Command, response:", "debug"
        for (result in ret.toString().split("(?<=\\G.{1950})")) { // Split the long line into max 1950 characters on each line
            log.debug "$result"
            child?.log "$result", "debug"
        }
        sent = true
    } else if (enableRetry) {
        log.error "Failed to query custom command"
        child?.log "Failed to query custom command", "error"
        sent = false
    }

    return sent
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy server"
    
    def appName = "Blink Camera Manager"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoyServer, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def devices = getChildDevices()
                if (devices) {
                    def deviceName = devices[0].currentValue("dhName")
                    def deviceVersion = ret.data?."$deviceName"
                    if (deviceVersion && (deviceVersion > devices[0].currentValue("codeVersion"))) {
                        def msg = "New version of device ${devices[0].displayName} available: $deviceVersion, version: ${devices[0].currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                        log.info msg
                        if (!disableUpdateNotifications) {
                            sendPush(msg)
                        }
                    } else {
                        log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${devices[0].currentValue("codeVersion")}"
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}

// Rate Limit to 50 Transactions per 5*60 seconds
private rateLimitExceeded(def x = "", def reset = false) {
    def retVal = false
    def rate = 50 // unit: transactions
    def per  = 5 * 60 * 1000 // unit: milliseconds

    if (reset || !atomicState."allowance${x}") {
        atomicState."allowance${x}" = rate // unit: transactions
        log.trace "Initializing Allowance $x: ${atomicState."allowance${x}"}"
        if (reset) {
            return retVal
        }
    }
    if (reset || !atomicState."last_check${x}") {
        atomicState."last_check${x}" = now() // Unit: milliseconds
        log.trace "Initializing Last Check $x: ${new Date(atomicState."last_check${x}")}"
        if (reset) {
            return retVal
        }
    }

    def current = now() // Unit: milliseconds
    def time_passed = current - atomicState."last_check${x}" // Unit: milliseconds
    log.trace "Passed $x: ${time_passed/1000} seconds"
    atomicState."last_check${x}" = current
    atomicState."allowance${x}" = (atomicState."allowance${x}" + (time_passed * (rate / per))) as BigDecimal // Patch for now as state doesn't support float
    if (atomicState."allowance${x}" > rate) {
        atomicState."allowance${x}" = rate // throttle
    }
    if (atomicState."allowance${x}" < 1) {
        retVal = true // discard transaction
        // Disable the next line if you don't want to penalize repeat offenders and allow it to reset after the duration (per)
        atomicState."allowance${x}" = atomicState."allowance${x}" - 1 // Continue to deplete the count to block continuous offenders
    } else {
        retVal = false // continue with transactions
        atomicState."allowance${x}" = atomicState."allowance${x}" - 1
    }
    
    log.trace "Allowance $x: ${atomicState."allowance${x}"}, Last Check: ${new Date(atomicState."last_check${x}")}"
    
    return retVal
}

def resetRateLimits(evt) {
    log.trace "Resettings rate limits for all devices"
    
    getChildDevices().each { device ->
        rateLimitExceeded(device.deviceNetworkId, true) // Reset the rate limit for each device
    }
}